#指令
> 指令不依赖于控制器

> 指令默认不产生作用域，可以声明作用域

> 指令的分类


    装饰型(负责添加功能的) 
    组件式(替换成一个完整的组件)
    组件
    
##指令格式
```
<!--Attribute   A-->
<div my-drag></div>属性
<!--Element     E-->
<my-drag></my-drag>标签
<!--Class       C-->
<div class="my-drag"></div>类
<!--Comment     M-->
<!-- directive:my-drag -->注释(注意这里--后面前面都是空格)
```
js中这么写
```
app.directive('myDrag',function () {  //ECMA 命名规范多个单词以-连接，js中采用驼峰命名
       return { //默认生效的是A E
           restrict:'ACEM', //限制使用范围 每一个字母代表一种格式
           replace:true,//替换外层的原有标签，要求模板必须有一个根节点
           template:`<div>
                        <h1>HELLO angular</h1>
                        <p>你好</p>
                     </div>`
           //只要涉及到模板替换,外面就要有一个根节点
       }
```
###link
```
app.directive('colorRed',function () {
        return {
            restrict:'A',
            //操作dom
            link:function (scope,element,attr) { //链接 连接作用域和视图的
                //scope代表当前指令所在作用域，指令没有创建作用域，使用的是上一级
                //attr 代表的是当前指令上的所有属性
                //element 当前指令所在的元素,可以调用ele身上的系列方法操作DOM                            angular中要求增加单位px
                element.css({'color':'red','font-size':'100px'});
                console.log(attr);
            }
        }
```
####指令实现angular版拖拽
```
app.directive('drag',function () {
        return{
            restrict:'A',
            link:function (scope, ele, attr) {
                ele.on('mousedown',function (e) {
                    console.log('ok')
                    var disX=e.pageX-this.offsetLeft;
                    var disY=e.pageY-this.offsetTop;
                    angular.element(document).on('mousemove',function (e) {//这里的angular.element(document)就是jQuery中的$(document),但它不支持选择器angular.element('div')会报错
                        ele.css({
                            top:(e.pageY-disY)+'px',
                            left:(e.pageX-disX)+'px'//angular中要加'px'
                        })
                    });
                    angular.element(document).on('mouseup',function () {
                        angular.element(document).off();
                    })
                    e.preventDefault()//阻止默认事件(选中文字)
                });
            }
        }
    })
```
###组件式
1. @ 引用字符串
```
<input type="text" ng-model="title">
<panel title="{{title}}">1</panel>
```
```
<script>
    var app = angular.module('appModule', []);
    app.run(['$rootScope',function ($rootScope) {
        $rootScope.title='标题';
    }])
    app.directive('panel', function () {
        return {
            restrict: 'E',
            template: '<input ng-model="tit"/>',//模板引入路径时，用templateUrl
            transclude: true,// 保留指令中的内容
            link: function (scope, ele, attr) {
//            scope.tit=attr.title; // 把tit挂在当前作用域上，未设置作用域时，为根作用域
            },
            scope: {
                tit: '@title'//@取得是字符串，相当于scope.tit='标题'
            }

        }
    })
</script>
```
2. = 引用scope上的属性
```
<panel title="title">1</panel>
```
```
   tit:'=title'  //= 取得是作用域上的变量，这里相当于scope.tit=$rootScope.title
```

>- @和=的区别

@是单向绑定，=是双向的

3. &绑定函数
```
<input type="text" ng-model="name">
<panel ss="say(a,b)" name="{{name}}"></panel>
<script>
    //指令中拥有独立作用域，将方法通过属性传递到指令中 传递的时候需要用(属性="作用域上的方法()",指令中用&符号来接收
    var app = angular.module('appModule',[]);
    app.run(['$rootScope',function ($rootScope) {
        $rootScope.name='我';
        $rootScope.say = function (who,where) {
            alert(who);
            alert(where)
        }
    }]);
    app.directive('panel',function () {
        return {
            restrict:'E',
            template:`<button ng-click="s({a:name,b:'很好'})">say</button>`,
//            template:'<button ng-click="s({a:\'你好\'})">say</button>',
            scope:{
                name:'@name',
                s:'&ss'
            }
        }
    })
</script>
```


