## node主线程是单线程（内核是多线程的）
- java多线程

## 进程可以包含多个线程

## 1个进程里面只能有一个线程（开一个子进程）

## 边睡觉边看电视(同一时间内只能干一件，切换速度非常快)

## 异步和同步
- 同步是代码依次执行
- 同步代码执行后在执行（定时器,callback）

## 阻塞和非阻塞
- 主要针对内核来说的

> 效率高，能学会自己写接口,前后端分离,node可以写网站ejs jade


## MAC安装
安装homebrew
https://brew.sh/index_zh-cn.html
```
brew install git
```

> 安装过xcode会自动安装git

## 使用git
- 告诉git你是谁？
```
git config --global user.name zhufengzhufeng
git cinfig --global user.email 894918097@qq.com
```

> 只需设置一次(没有设置则不能提交)

## 查看配置
```
git config --list
```

## 创建文件
```
mkdir(make directory) 文件名 -p可以循环创建
```

## 删除目录
```
rm -rf 文件夹
```

## 查看目录下所有文件
```
ls -al
```

## 版本控制(文件)
- 初始化使用git的位置
```
git init (初始化)
```

## vi编辑
```
vi 1.txt
i 插入  变成编辑模式
esc + :wq(保存+退出) 退出  命令模式
esc + :q!(强制退出)
```

## 查看文件内容
```
cat 文件名
```

## 将文件进行提交
- 将文件加入到暂存区中(不能直接提交到历史区)
```
git add .或者-A或者<文件名>
```

## 提交到历史
```
git commit -m ''
```

> 必须要备注提交参数

## 查看提交历史
```
git log(日志)
```

## 代码比较
- 工作区和暂存区
```
git diff (不同different)
```
- 工作区和历史区
```
git diff master
```
- 暂存区和历史区
```
git diff --cached(暂存区)
```

## checkout
- 从暂存区拉回工作区
```
git checkout 文件名
```

## 取消本次add
- 将暂存区中的内容回到上次add的情况
```
git reset HEAD '文件名'
```

## 回到过去&&回到未来
- 回到过去
```
git log (获取commit_id)
git reflog (记录着所有版本)
git reset --hard  commit_id
```

> log只能查看当前版本之前的内容;

## 分支
- 主干，通过主干建立一个分支，当代码完成后确认无误后在合并到主干上

## 创建分支
- 会在当前状态下克隆一份一模一样的
```
git branch dev
```

> 查看分支git branch

## 切换分支
```
git checkout dev
```

## 删除分支
```
git branch -D dev
```

## 创建分支并切换
```
git checkout -b(分支) dev
```

> 要将内容提交到dev分支上，才会归dev管理，否则只是工作区的内容

## 合并分支
```
git merge dev
```

> 在master上合并dev分支

> 刚刚我们创建的分支和主干一模一样，在分支上改动了一下，很快的在主干上合并了，如果在改动分支的时候 主干也改动了（div{background:red}） 分支来了一段代码(div{background:yellow}),手动解决冲突

##  提交连写
```
git commit -a -m 'commit'
```

> 首次提交的文件不能使用这种方式提交

## 解决冲突
- 在文件内保留最后想留下的结果（去掉>>>>><<<<=====）
- 提交最终的结果

## 发布到github上
- 如果线上有内容，先要将线上的拿下来，再次提交
- 初始化空仓库

# origin
## 创建readMe文件(可以不创建)
```
echo '# welcome ' >> README.md
```

## 添加忽略文件
```
touch .gitignore
.DS_Store
.idea
```

## 添加远程仓库
```
git remote add origin https://github.com/zhufengzhufeng/201614nodetest.git

```

## 删除远程仓库
```
git remote rm 仓库
```

## 推送到远程仓库
```
git push origin master -u(upstream)
```

## 部署静态的github页面
- 先建一个仓库 static
- git init (初始化本地仓库)
- git checkout -b gh-pages (分支名不能更改)
- git add . (添加到暂存区)
- git commit -m"trans" (提交到历史区)
- git remote add origin 地址
- git push origin gh-pages

## 合作 老师 组长 组员
- 组长fork老师的项目
- 将代码下载到本地
```
git clone 地址 文件夹的名字
```

## 组长给组员开通权限
```
自己的仓库下点击settings > Collaborators 添加用户
```

## 开通权限后组员操作
- 组员将代码克隆下来
- 找到自己组放自己的文件夹
- git add .
- git commit -m 'xxx作业ok'
- git pull origin master(拉取组长仓库最新代码，防止提交后覆盖)
- git push origin master


## global
- process
    - nextTick 下一队列（当前队列的底部）
    - process.pid 进程的id
    - process.kill() 杀死进程
    - process.cwd() 当前工作目录（__dirname不可以更改的）
    - process.exit() 退出进程
- Buffer
- setTimeout / clearTimeout
- setInterval / clearInterval
- setImmediate / clearImmediate
- console
    - console.log/error/info/warn/time/timeEnd

## __dirname/__filename

## 模块化
- cmd(seajs)就近依赖  amd(requirejs) 依赖前置
- commonjs (node) 读写文件io操作
- 有利于分工协作，
- 高内聚，低耦合
- 实现代码复用

> 闭包，命名空间(不可能完全避免命名冲突，调用过长)

## 模块化
- 定义模块（创建一个js文件）
- 使用模块（require）
- 导出模块（exports / module.exports）

## 文件模块
- 引用方式要通过相对路径引用
- 引用多次 只执行一次

## 第三方模块
- npm管理后台文件的 管理前端文件bower
- 别人的模块 npm
- 下载文件通过npm
    - 全局下载(只在命令下使用)
        - nrm工具(切换源的)
        ```
        npm install nrm -g
        ```
        - 添加一个源
        ```
        nrm add zf1 http://172.18.1.139
        ```
        - 展示所有源
        ```
        nrm ls
        ```
        - 测试源
        ```
        nrm test
        ```
        - 切换源
        ```
        nrm use taobao
        ```
        - nodeppt
        ```
        npm install nodeppt -g
        ```
    - 本地下载(在代码里使用)
        - 记录安装过的所有模块
        ```
            npm init(记录所有的依赖关系) -y默认确定
        ```
        - 依赖(开发上线都需要)
        ```
        npm install jquery@2.1.0 --save  缩写(-S)
        ```
        - 开发依赖(只在开发使用)
        ```
        npm install gulp --save-dev  缩写(-D)
        ```
    - 卸载模块
        ```
            npm uninstall nodeppt -g
            npm uninstall jquery --save
            npm uninstall gulp --save-dev
        ```


## 查看版本
```
npm info jquery
```
## 安装固定版本
```
npm info jquery@1.0.0
```

> 默认安装到node_modules文件夹下,不指定版本默认为最新版本

## 模块的查找
先查找当前目录下node_modules文件，找到名字相同的文件夹，找到package.json看里面的main，运行main对应的文件，找不到会像上级查找node_modules文件，直到找到为止（根目录），找不到则报错 （如果找不到 会默认找index.js）

## bower
- 先安装bower
```
npm install -g bower
```
- 初始化bower.json
```
bower init
```
- 下载插件
```
bower install jquery --save
```

> 默认安装到bower_components文件夹下

## bower可以指定目录安装
```
touch .bowerrc
{"directory":"lib/public/js"}
```

## 发包
- 找到带有package.json的文件夹
- 切到官方npm上
```
nrm use npm
```
- 登录账号
```
npm addUser
```
- 发布
```
npm publish
```

## 核心模块/内置模块
- node自带的模块，不需要安装，可以直接使用
- util工具模块

##  指令

- 1.指令是不依赖于控制器的
- 2.指令默认不会产生作用域 也可以声明创建作用域
  + 1） 指令的分类 装饰型（负责添加功能的）  组件式（替换成一个完整的组件） 复用
  + 2) 指令的格式
   + ECMA 命名规范多个单词以-连接，js中采用驼峰命名
   + 默认生效的是AE
   + restrict:'ACEM',限制使用范围 每一个字母代表一种格式
   + replace:true,替换外层的原有标签，要求模板必须有一个根节点，只要涉及到模板替换,外面就要有一个根节点

- 3.scope代表当前指令所在作用域，指令没有创建作用域，使用的是上一级
   + element 为jq对象 ，就是angular.element包装过的
   + attr 代表的是当前指令上的所有属性

- 组件式
   + 封装好了一个组件 可以多次调用
   + 将数据挂在作用域上 视图可以通过{{}}来获取值
   + {} 通过true {} 创建一个独立作用域

   + @符号取得是字符串  @符是单项的
   + =号传递的是变量    =是双向的
   + 指令中拥有独立作用域，将方法通过属性传递到指令中 传递的时候需要用(属性="作用域上的方法()",指令中用&符号来接收


 - angular提供的服务 都可以自动调用$apply,不需要手动调用   watch+apply就实现了 双向数据绑定

 - 不是angular中的方法，改变数据，不会刷新视图
    + $scope.$apply();告诉angular数据有变化，刷新视图

 - 1.ng-model不会产生作用域
 - 2.监控输入框中的输入的值 将值赋到作用域上  v->m
 - 3.监控作用域上的值，将值赋给输入框  m->v


 - 改变了协议  域名  端口  都叫   jsonp 跨域
 ## 服务
 - 1.放置在根作用域上
   + 1）默认provider会被实例化
   + 2）当我们在控制器中使用服务会调用他的$get方法
   + 1.provider是最大的服务，可以进行配置
   + angular中提供了五种服务 用的时候 我一般采用factory
    + provider,"factory",service,constant,value