# Git

### git的使用
    功能：类似于网盘  http://ohmyz.sh/

### mac 安装
- 先安装homebrew  &&& https://brew.sh/index_zh-cn.html
- brew install git

> 安装过xcode会自动安装git

### 使用git

- 1.告诉git你是谁

```
     git config --global user.name zumingshuang
     git config --global user.email 1021007249@qq.com
     注意:没有设置则不能提交(只能设置一次)
     git config --list 查看配置列表
```

- 2.git的作用  版本控制(文件)

```
     1. 初始化使用git的位置
     2. mkdir useGit 创建一个 useGit 文件夹 mkdir useGit/aa/bb -p 循环创建 <br/>
        mkdir(make directory) 文件名
     3. cd useGit/ 进入到这个文件夹内
     4. rm -rf a 循环删除(一旦删除永远找不回)<br/>
        rm -rf 文件夹   删除目录
     5. ls 查看
     6. ls -al 查看目录下所有的文件
     7. git init 初始化一个空厂库
```

- 3.文件编辑

```
    1. touch 1.txt 创建文件
    2. vi 1.txt 编辑进入文件  出现 -> 用 i 键 insert进入  编辑代码
    3. esc + :wq 保存并且退出
    4. esc + :q! 强制退出
    5. cat 1.txt 查看文件内容是否存在
```
- 4.将文件进行提交

```
    1. 将文件加入到暂存区中(不能直接提交到历史区)
    2. git add -A或者.或者1.txt(文件名)  添加所有的文件名
    3. git status/  查看状态
    4. git stage    暂存区
    5. git commit -m '输入说明'  提交到历史(注意--》必须要备注提交参数)
    6. git log(日志)   查看提交历史
```

- 5.代码比较  查看代码  增加和减少

```
    1. git diff  比较工作区域和暂存区域
    2. git diff master 当前工作区域和历史区域比较(master:是根据分支名改变而变)
    3. git diff --cached  暂存区域和历史区域比较
```
- 6.暂存区和工作区的文件修改

```
    1. git checkout 1.txt(文件名)  把暂存区域的源文件拉回来到工作区并且覆盖本地的文件
    2. git reset HEAD '1.txt ' 将暂存区的内容移除  返回最初的源文件
```
- 7.回到过去 && 回到未来

```
    - 回到过去
    1. git log  获取id (b0d6c6e1:git log  查看日志:只能查看当前版本之前的内容)
    2. git reset --hard b0d6c6e1 回到过去

    - 回到未来
    1. git reflog  查看你所有的日志情况
    2. git reset --hard b0d6c6e1 回到未来
    git log --grep zz 根据参数名搜索
```
- 8.git的分支管理
  + 主干:通过主干建立一个分支，当代码完成后确认无误后再合并到主干上
  + 创建分支:会在当前代码下克隆一份一模一样的
  ```
        1. git branch 查看分支
        2. git branch dev 创建分支
        3. git checkout dev 切换分支
        4. git branch -D dev 删除分支
        5. git checkout -b dev 创建并且切换分支
  ```
  + 要将内容提交到dev分支上管理，否则只是工作区的内容
  + 在master合并分支
  ```
        1. git checkout master 进入主分支
        2. git merge dev  合并分支
  ```
- 9.主干和分支一模一样，如何解决这个冲突?

```
    1. 在文件中保留最后想留下的结果
    2. 提交最终结果

    git commit -a -m'dj'  提交连写(首次提交的文件不能使用这种方式提交)
```
### 把本地文件上传到GitHub上

        - 如果线上有内容，先将线上的拿下来，在次提交
        - 初始化厂库

- origin

```
    1. 创建 readme.md 文件(可以不创建)
    2. echo "#hello" > readme.md  创建文件
    3. touch .gitignore  && .DS_Store && .idea  忽略文件(里面都是我们不需要的文件)
```


- 添加远程仓库

```
     1. git init 初始化
     2. git add README.md  添加 暂存区
     3. git commit -m "first commit"  提交  历史区
     4. git remote add origin https://github.com/zumingshuang/myread.git  添加
     5. git remote rm 仓库   删除远程仓库
     6. git push  origin master -u(upstream) 推送到远程仓库
     7. git remote -v  查看通道
```


- 部署静态的GitHub页面(就是把自己本地文件上传到git)

```
     1. 先创建一个仓库hello
     2. git init  初始化本地仓库
     3. git checkout -b gh-pages  分支名不能更改
     4. git add .  添加到暂存区
     5. git commit -m'hello' 提交到历史区
     6. git remote add origin+ 地址
     7. git push origin gh-pages 推送
     8. 然后git上点击settings里面找到https://zumingshuang.github.io/hello/
```


- 交作业流程

```
    1. 组长fork老师的项目(不能fork多次)
    2. git clone + 老师地址 + 文件夹名字
    3. git add . 推送本地文件
    4. git commit -m''
    5. git push origin master
    6. new pull request
```

- 组长给学员开通权限

```
    自己的仓库下点击settings > Collaborators 添加用户
```
- 开通权限后组员操作

```
    1. 组员将代码克隆下来
    2. 找到自己组放自己的文件夹
    3. git add .
    4. git commit -m'xxx作业'
    5. git pull origin master  拉取组长仓库最新代码，防止提交后覆盖
    6. git push origin master
```

# Node

### node特点 主线程是单线程的(内核是多线程)
- Java 是多线程
- 进程可以包含多个线程
- node 一个进程里面只有一个线程(可以开一个子进程)
- 多线程 同一时间内只能干一件事，切换速度非常快

每次开启一个node程序 就会开一个进程

### exports
        1.exports {Person:Person}
          module.exports = Person;
- 默认 module.exports和exports指向的是同一个空间,最后返回的是module.exports
-  目的是改变module.exports
- 1.在exports上增加属性            导出多个可以采用exports的方式
- 2.直接改变module.exports的指向   导出引用数据类型module.exports
-  x 不能改变exports的指向

module.exports.calc = calc;
在useComputed中使用 calc方法


### 异步和同步
- 异步 同步代码执行后在执行的代码(例如：定时器 callback)
- 同步 代码依次执行
- require是一个同步方法，有回调函数一般都是异步,有返回值的一般是同步

### 阻塞/非阻塞
- 主要针对内核来说

>效果高，自己写接口，前后端分离 node 可以写网站ejs jade

### 继承
- inherits继承
- call 只能继承父亲的私有方法  Parent.call(this);
- Child.prototype = new Parent(); //继承父亲所有属性
- Child.prototype.__proto__ = Parent.prototype;//原型链继承
- create原理 创建一个函数，将函数的原型指向传入的原型，new函数 new出来的实例上只包含公有方法，赋值给儿子的原型

### global

- process
  + nextTick  下一队列(当前队列的底部)
  + process.pid  进程的id
  + process.kill() 杀死进程
  + process.cwd()  当前工作目录(__dirname不可以更改的)
  + process.exit() 退出进程
- Buffer
- setTimeout   / clearTimeout
- setInterval  / clearInterval
- setImmediate / clearImmediate
- console
  + console.log / error / info / warn / time / timeEnd

### 进制
- buffer缓冲区，操作的是二进制数据，表现出来的是16进制
-  逢10进1
- 八个二进制数组成字节 1b = 8bit(八个二进制)
- utf8中 一个汉字几个字节 3个
- 当前所在位的最大值*当前进制^(所在位-1) 累加的和
- 存的是16进制 010  将255 转化成16进制 0xff
- 16进制每一个字节最大ff 大小都在0-ff之间

### __dirname / __filename

### 模块有缓存

- 引用模块会有缓存的机制,可以操作缓存，但是不要操作
- 代码都会执行的，你导出后 别人才可以引用你的方法

### 模块化
- cmd(seajs)就近依赖  &&  amd(requirejs) 依赖前置
- commonjs (node) 读写文件io操作
- 有利于分工协作
- 高内聚，低耦合
- 实现代码复用

> 闭包，命名空间(不可能完全避免命名冲突，调用过长)

### 模块化
- 定义模块(创建一个js文件)
- 使用模块(require)
- 导出模块(exports / module.exports)

### 文件模块
- 引用方式要通过相对路径引用
- 引用多次 只执行一次

### 第三方模块
- npm 管理后台文件的  管理前端文件bower
- 别人的模块 npm
- 下载文件通过npm
  + 全局下载(只在命令下使用)
       + nrm工具(切换源的)
       ```
            npm install nrm -g
       ```
       + 添加一个源
       ```
            nrm add zf1 http://172.18.1.139
       ```
       + 展示所有的源
       ```
           nrm ls
       ```
       + 测试源
       ```
            nrm test
       ```
       + 切换源
       ```
            nrm use taobao
       ```
       + nodeppt
       ```
            npm install nodeppt -g
       ```
  + 本地下载(在代码里使用)
       + 记录安装过的所有模块
       ```
            npm init(记录所有的依赖关系) -y 默认确定
       ```
       + 依赖(开发上线都需要)
       ```
            npm install jquery@2.1.0 --save  缩写(-S)
       ```
       + 开发依赖(只在开发使用)
       ```
            npm install gulp --save-dev  缩写(-D)
       ```
  + 卸载模块
       ```
        npm uninstall nodeppt -g
        npm uninstall jquery --save
        npm uninstall gulp --save-dev
       ```
### 查看版本
```
    npm info jquery
```
> 默认安装到node_modules文件夹下，不指定版本默认为最新版本

### 模块的查找
先查找当前目录下node_modules文件，找到名字相同的文件夹，找到package.json看里面的main,运行main对应的文件,找不到会像上级查找node_modules文件,直到找到为止(根目录),找不到则报错(如果找不到会默认找index.js)

### bower

- 先安装bower
```
    npm install -g bower
```

- 初始化bower.json
```
    bower init
```

- 下载插件
```
    bower install jquery --save
```

> 默认安装到bower_components文件夹下

### bower可以指定目录安装

```
    touch  .bowerrc
    {"directory":"lib/public/js"}
```

### 发包
- 找到带有package.json的文件夹
- 切到官方npm上
```
    nrm use npm
```
- 登录账号
```
    npm addUser

    Username    zz
    Password  123456
    Email  1021007249@qq.com
```
- 发布
```
    npm publish
```

### 核心模块 / 内置模块
- node 自带的模块，不需要安装，可以直接使用
- util 工具模块

### 搭建博客

- 安装hexo
```
    npm install hexo-cli -g  //提供一个命令 hexo
```
- 初始化博客
```
    hexo init
```
- 启动服务
```
    hexo serve -p 3333
```
- 下载主题
在themes文件夹下下载
```
    git clone https://github.com/iissnan/hexo-theme-next.git
```
### hexo g
- 生成发布的内容

### 安装插件
```
    npm install hexo-deploy-git --save
```

### 配置用户路径
```
    deploy:
    type:git
    repo:https://username:password@github.com/zumingshuang/zumingshuang.github.io.git,master
```
### 发布
```
    hexo deploy
```

### 新建仓库
名字要求  GitHub账号名.github.io

姜文 18310349227

### webstorm 下载地址
> http://www.jetbrains.com/webstorm

### 破解地址
> http://idea.lanyus.com/


# Angular

### angular框架
- 框架
  + 强约束，被动调用
- 库 jQuery react
  + 主动调用库中的方法，弱依赖

### 下载angular

- 先去生成一个package.json 生成后 在安装时会以当前package.json文件位置来安装模块
```
    npm init
```
初始化package.json
```
    npm init -y
```

- npm(管理后台模块)
下载node后才会有,node package manager
```
    npm install angular
```
> 使用npm install 安装时如果上一级有node_modules文件会安装到上一级上

> 文件名字不能是中文，而且不要以已经存在的项目名字命名

### MVC
- model 数据层
- view  视图层
- controller 控制器

### MVVM
- model 数据层
- view 视图层
- viewModel 视图模型
> 将数据挂载在viewModel上可以实现数据和模型的双向绑定

### ng-app
- 告诉angular启动项目
- 添加根作用域$rootScope

### ng-model
- 实现双向数据绑定的
```
   <input type="text" ng-model="name"/>
```
1.先去当前作用域上找name，如果有会将name变量的值赋予给输入框
2.如果没有，当我们在输入框中输入内容，会在当前作用域下声明这个name变量
3.修改输入框中的内容 会导致数据的更新

> ng-model只能放置变量名

### ng-bind 简写{{}}
- 将作用域上的数据展示到页面上
- 数据的变化可以影响视图
- 支持赋值，运算，三元表达式

### ng-cloak
- 防止闪烁，先让所有带有ng-cloak的属性隐藏掉。当angular加载后，会自动移除掉ng-cloak属性。
```
   [ng-cloak]{display:none}
```
### 创建独立作用域
模块化开发， 单例， 闭包-》cmd(seajs) amd(requirejs)

### 创建模块
```
   ng-app="appModule"
   var app = angular.module('appModule',[]);
```

### 安装模块
```
   npm install angular bootstrap
```

### 查看模块的所有版本
```
   npm info jquery
```

### 安装指定版本
```
   npm install jquery@2.1.0
```

### 创建控制器
- $scope就是我们的viewModel
```
   ng-controller="myCtrl"
   app.controller('myCtrl',function($scope){});
```

### 控制器特点
- 控制器可以嵌套，子能继承父，父不能继承子
- 不能操作DOM

### run方法
- 声明全局数属性
```
   app.run(function($rootScope){})
```

### ng-repeat
- arr
- obj
```
   <ul>
        <li ng-repeat="(key,one) in arys track by $index"></li>
   </ul>
```
### bootstrap

## 过滤器
### 内置过滤器
- uppercase
- lowercase
- date
```
 {{12333312212 | date:'yyyy-MM-dd hh:mm:ss'}}
```
- limitTo
- number
- currency
- json
- orderBy
```
   <div ng-repeat="arr in arrs | orderBy:'name':true/false track by $index"></div>
```
- filter
```
   <div ng-repeat="arr in arrs | filter:{name:1} track by $index"></div>
```

### 自定义过滤器
- 独立的功能和控制器无关
```
   var app = angular.module('appModule',[]);
   app.filter('竖线后面的名字',function($sce){
   // 服务
      return function(过滤器的数据，冒号后的参数){ // 参数有多个以冒号传入
            return '显示的结果'
      }
   })
```
。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。

## 指令

### directive(指令)
- 1.指令是不依赖于控制器的
- 2.指令默认不会产生作用域 也可以声明创建作用域
>
- 1） 指令的分类 装饰型（负责添加功能的）  组件式（替换成一个完整的组件） 复用
- 2） 指令的格式
>
- 创建指令

```
    var app = angular.module('appModule',[]);
    app.directive('myDire',function () {
        return {

        }
    });

```

- 模板

```
   var app= angular.module('appModule',[]);
       app.directive('myDrag',function () {  //ECMA 命名规范多个单词以-连接，js中采用驼峰命名
          return { //默认生效的是AE
              restrict:'ACEM', //限制使用范围 每一个字母代表一种格式
              replace:true,//替换外层的原有标签，要求模板必须有一个根节点
              template:`<div>
                           <h1>HELLO angular</h1>
                           <p>你好</p>
                        </div>`
              //只要涉及到模板替换,外面就要有一个根节点
          }
       });
```

```
    Attribute   简写 A  属性
    Element     简写 E  元素
    Class       简写 C 名字
    Comment     简写 M 注释
    directive:my-drag
```

### 装饰型指令

- restrict  限制范围
- link  连接作用域和视图的
  + link中的scope --》代表当前指令所在作用域，指令没有创建作用域，使用的是上一级
  + 当前指令所在的元素,angular中要求增加单位px
  + attr 代表的是当前指令上的所有属性
```
    var app = angular.module('appModule',[]);
        app.directive('colorRed',function () {
            return {
                restrict:'A',//限制范围
                //操作dom
                link:function (scope,element,attr) { //链接 连接作用域和视图的
                    //scope代表当前指令所在作用域，指令没有创建作用域，使用的是上一级
                    //当前指令所在的元素,angular中要求增加单位px
                    element.css({'color':'red','font-size':'100px'});
                    //attr 代表的是当前指令上的所有属性
                    console.log(attr);
                    //1.mousedown mousemove mouseup   //DOMMouseScroll  mousewheel
                }
            }
        })
```

### 组件式

- attr props 想传递一些数据可以通过属性传递

```
    var app = angular.module('appModule',[]);
        app.directive('panel',function () {
            return {
                restrict:'E',
                //封装好了一个组件 可以多次调用
                templateUrl:'tmpl/panel.html',//通过路径 引用html
                transclude:true,//保留内容，嵌入到panel中
                /*link:function (scope,element,attr) {
                    //想拿到attr中的属性放到heading中
                    scope.title = attr.title; //将数据挂在作用域上 视图可以通过{{}}来获取值
                },*/
                scope:{
                    title:'@title' //scope.title = attr.title;
                }  // {} 通过true {} 创建一个独立作用域
            }
        })
```

### scope

- scope:true  不断绝父子关系，仍然可以向上查找
- scope:{}    断绝父子关系，就是和$rootScope平级

```
    <body>
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <input type="text" ng-model="title">
                <!--tit和say的名字 是为了做传递   后面的内容都是作用域上定义的数据或者方法-->
                <panel tit="title" say="say(tit)">这是内容1</panel>
                <panel tit="title" say="say(tit)">这是内容2</panel>
                <panel tit="title" say="say(tit)">这是内容3</panel>
            </div>
        </div>
    </div>
    <script src="node_modules/angular/angular.js"></script>
    <script>
        var app = angular.module('appModule',[]);
        app.run(['$rootScope',function ($rootScope) {
            $rootScope.title = 'zfpx';
            $rootScope.say = function (title) {
                alert(title);
            }
        }]);

        app.directive('panel',function () {
            return {
                restrict:'E',
                templateUrl:'tmpl/panel.html',//通过路径 引用html
                transclude:true,//保留内容，嵌入到panel中
                scope:{  //scope.title = 'zfpx1';//声明的是一个字符串 和外面作用域上的值没关系
                    title:'@tit',//@符号取得是 title对应的字符串 ,前后名字相同可以去掉
                    sayTitle:'&say'
                } // title sayTitle是当前视图调用时用的名字
                //默认不产生作用域 而且拥有父子关系
                //true不断绝父子关系，仍然可以向上查找
                //{} 断绝父子关系，就是和$rootScope平级
            }
        })
    </script>
    </body>
```

### @符号

```
    <body>
    <input type="text" ng-model="zfpx">
    <panel tit="{{zfpx}}"></panel>
    <script src="node_modules/angular/angular.js"></script>
    <script>
        var app = angular.module('appModule',[]);
        app.run(['$rootScope',function ($rootScope) {
            $rootScope.zfpx = 'zfpx'
        }]);
        //@符号取得是字符串  @符是单项的
        app.directive('panel',function () {
            return {
                restrict:'E',
                template:'<input ng-model="title"/>',//通过路径 引用html
                scope:{
                    //属性的值发生变化 会重新给指令赋新的值
                    title:'@tit' //scope.title = 'zfpx'
                }
            }
        })
    </script>
    </body>
```

### = 符号

```
    <body>
    <input type="text" ng-model="title">
    <panel tit="title"></panel>
    <script src="node_modules/angular/angular.js"></script>
    <script>
        var app = angular.module('appModule',[]);
        app.run(['$rootScope',function ($rootScope) {
            $rootScope.title = 'zfpx'
        }]);
        //@符号取得是字符串  @符是单项的
        //=号传递的是变量    =是双向的
        app.directive('panel',function () {
            return {
                restrict:'E',
                template:'<input ng-model="bb"/>',//通过路径 引用html
                scope:{
                    //属性的值发生变化 会重新给指令赋新的值
                    bb:'=tit' //scope.bb =$rootScope.title =
                }
            }
        })
    </script>
    </body>
```
### &符号(and符)

```
    <body>
    <input type="text" ng-model="title">
    <panel ss="say(a,b)"></panel>
    <script src="node_modules/angular/angular.js"></script>
    <script>
        //指令中拥有独立作用域，将方法通过属性传递到指令中 传递的时候需要用(属性="作用域上的方法()",指令中用&符号来接收
        var app = angular.module('appModule',[]);
        app.run(['$rootScope',function ($rootScope) {
            $rootScope.say = function (who,where) {
                alert(who);
                alert(where)
            }
        }]);
        app.directive('panel',function () {
            return {
                restrict:'E',
                template:`<button ng-click="s({a:'你好',b:'不好'})">say</button>`,
    //            template:'<button ng-click="s({a:\'你好\'})">say</button>',
                scope:{
                    s:'&ss'
                }
            }
        })
    </script>
    </body>
```

### open

- ng-hide或者ng-show操作的是样式
- ng-if操作的是dom元素 （会产生一个作用域）如果if为false则内部代码不执行

```
    <script>
        var app = angular.module('appModule',[]);
        app.directive('listGroup',function () {
           return {
               restrict:'E',
               controller:function ($scope) {
                   $scope.lists = [];
                   this.collect = function (s) {
                       $scope.lists.push(s); //收集两个人作用域 可以控制两个人的flag属性
                   };
                   this.tell = function (s) {
                       $scope.lists.forEach(function (item) {
                           if(s!=item){
                               item.flag = false;
                           }
                       });
                   }
               },
               scope:true
           }
        });
        app.directive('listOne',function () {
            return {
                restrict:'E',
                require:'^?listGroup', //加上?如果找不到则是null
                templateUrl:'tmpl/open.html',
                transclude:true,
                link:function (scope,element,attrs,groupCtrl) {
                    groupCtrl.collect(scope);
                    scope.flag = false;
                    scope.toggle = function () { //点击时 告诉父亲 自己是谁，除了自己的都关闭掉
                        groupCtrl.tell(scope); //将自己的作用域传到父亲那
                        scope.flag =!scope.flag
                    }
                },
                scope:{
                    title:'@type'
                }
            }
        });
        /*app.controller('toggleCtrl',function ($scope) {
            $scope.flag = true;
            $scope.toggle = function () {
                $scope.flag =! $scope.flag;
            }
        })*/
    </script>
```
```
    <script>
        var app = angular.module('appModule',[]);
        app.directive('listGroup',function () {
            return {
                controller:function () {
                    var arr = [];
                    this.collect = function (s) {
                       arr.push(s);
                    };
                    this.tell = function (s) {
                        arr.forEach(function (item) {
                            if(item!=s){
                                item.flag = false;
                            }
                        })
                    }
                },
                scope:true
            }
        });
        app.directive('listOne',function () {
            return {
                require:'^?listGroup',
                templateUrl:'tmpl/open.html',
                transclude:true,
                link:function (s,e,a,groupCtrl) {
                    groupCtrl.collect(s);
                    s.flag = false;
                    s.toggle = function () {
                        groupCtrl.tell(s);
                        s.flag = !s.flag
                    }
                },
                scope:{
                    title:'@type'
                }
            }
        })
    </script>

```

### 指令和指令间的交互

```
    <body ng-controller="my">
    <girl cry eat>XXXX</girl>
    <script src="node_modules/angular/angular.js"></script>
    <script>
        var app = angular.module('appModule',[]);
        app.directive('girl',function () {
            return {
                //这个控制器 代表的就是指令的控制器
                controller:function ($scope) {
                   $scope.arr = []; //存放数据
                   this.say = function (kinds) { //点击xxxx弹出eat和cry
                       $scope.arr.push(kinds);
                   }
                },
                link:function (scope,element,attrs) {
                    element.on('click',function () {
                        alert(scope.arr);
                    });
                },
                scope:{}
            }
        });
        app.directive('eat',function () {
            return {
                require:'^girl',// ^ 找不到则向上找，如果找不到不想报错^?
                link:function (scope,element,attrs,gCtrl) {//会将girl的controller进行实例化，并且放在第四个参数上
                    //默认指令的作用域会向上查找，跳过包含他的指令
                    gCtrl.say('eat');
                },
            }
        });
        app.directive('cry',function () {
            return {
                require:'girl',
                link:function (scope,element,attrs,gCtrl) {
                    gCtrl.say('cry');
                },
            }
        });
    </script>
    </body>
```
### $watch

```
    <body ng-controller="myCtrl">
    <input type="text" ng-model="name" ng-change="change()">
    <span ng-bind="age"></span>
    <script src="node_modules/angular/angular.js"></script>
    <script>
        var app = angular.module('appModule',[]);
        app.controller('myCtrl',function ($scope) {
            //当输入的name值为偶数的时候 让age+1,如果age增加了 监控age如果age>10 弹层说age大于10了
            $scope.age = 1;
            //监控的第一个参数可以为作用域上属性名，还可以是函数
            //$scope.$watch('age');
            $scope.$watch(function () {
                console.log(1);
                //只要页面有任何一个值变化就会执行此函数,并且将函数的返回结果传入到另一个函数中
                return $scope.age;
            },function (newVal,oldVal) {
                //age发生变化就会执行
                if(newVal>4){
                    alert('age大于4了')
                }
            });
            $scope.change = function () {
                if($scope.name%2==0){
                    $scope.age++;
                }
            };
        })
    </script>
    </body>
```

### 例子 满百包邮

```
    <body ng-controller="myCtrl">
    商品名称 {{product.name}} <br>
    商品价格 {{product.price}}<br>
    商品数量 <input type="text" ng-model="product.count"><br>
    邮费 {{product.free}}<br>
    总额 {{sum()+product.free}}<br>
    <script src="node_modules/angular/angular.js"></script>
    <script>
        var app = angular.module('appModule',[]);
        app.controller('myCtrl',function ($scope) {
            $scope.sum = function () {
                return $scope.product.count*$scope.product.price
            };
            //脏值检查  效率低   数据劫持+观察者模式(on run ) Object.defineProperty
            $scope.$watch($scope.sum,function (newVal) {
                $scope.product.free = newVal>=100?0:10
            });
            /*$scope.$watch('sum()',function (newVal) {
                console.log(newVal);
            })*/
            $scope.product = {
                name:'可乐',
                price:2.5,
                count:1,
                free:10
            }
        })
    </script>
    </body>
```
### $apply

```
    <body ng-controller="myCtrl">
    {{date | date:'hh:mm:ss'}}
    <script src="node_modules/angular/angular.js"></script>
    <script>
        var app = angular.module('appModule',[]);
        app.controller('myCtrl',function ($scope,$interval,$timeout) {
            var timer = $interval(function () {
                $scope.date = Date.now();
                $interval.cancel(timer); //取消定时器
            },1000); //angular提供的服务 都可以自动调用$apply,不需要手动调用   watch+apply就实现了 双向数据绑定
            /*setInterval(function () {
                $scope.date = Date.now();
                //不是angular中的方法，改变数据，不会刷新视图
                $scope.$apply();//告诉angular数据有变化，刷新视图
            },1000);*/
        });
    </script>
    </body>
```
### 自定义model

```
    <body>
    <input type="text" zf-model="aa">
    {{age}}
    <script src="node_modules/angular/angular.js"></script>
    <script>
        //1.ng-model不会产生作用域
        //2.监控输入框中的输入的值 将值赋到作用域上  v->m
        //3.监控作用域上的值，将值赋给输入框  m->v
        var app = angular.module('appModule',[]);
        app.run(function ($rootScope) {
            $rootScope.aa = 'zfpx'
        });
        app.directive('zfModel',function () {
            return {
                restrict:'A',
                link:function (scope,element,attrs) {
                    //监控输入框中的输入事件         v->m
                    element.on('input',function () {
                        scope[attrs.zfModel] = element.val();
                        scope.$apply();//强制让视图刷新
                    });
                    //监控作用域上的值，将值赋给输入框 m->v
                    scope.$watch(attrs.zfModel,function (newVal) {
                        element.val(newVal);
                    });
                }
            }
        })
    </script>
    </body>
```

## 服务

### provider

- 最大的服务，可以配置
```
 app.config(function(CalcProvider){
       CalcProvider.age = 10;
 })
 app.provider('Calc',function(){
        this.age = 8;
        this.$get = function(){
            return {a:1}
        }
 })
```

### factory

```
  app.factory('Calc',function(){
      return {a:1}
  })
```

### service
```
   app.service('Clac',function(){
       this.a = 1;
   })
```

### value/constant
```
   app.value('Calc',{a:1});
   app.constant('Calc',{a:1});
```

### 安装文件
```
npm install angular-resource angular jquery bootstrap mime --save
```

### 先初始化package.json
```
npm init -y
```
### 安装模块
```
npm install bootstrap angular angular-resource angular-route jquery mime --save
```
### 单页开发
- 根页面  index.html
    - 添加页面 add.html  /add
    - 列表页面 list.html /list
    - 详情页 detail.html /detail/:id
    - 首页   home.html   /






























